import React from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Database,
  Shield,
  MemoryStick,
  Plug,
  HardDrive,
  Play,
  Pause,
  RotateCcw,
  Wifi,
  WifiOff,
  ArrowDown,
} from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";
import { Button } from "./ui/button";
import { Badge } from "./ui/badge";
import { Separator } from "./ui/separator";
import IncidentCommanderHeader from "./DashboardHeader";
import ActivityFeed from "./ActivityFeed";
import MetricsPanel, { incidentCommanderMetrics } from "./MetricsPanel";
import IncidentStatusPanel from "./IncidentStatusPanel";
import ConnectionStatusIndicator from "./ConnectionStatusIndicator";

// Import new hooks and utilities
import { useAutoScroll } from "../lib/hooks/useAutoScroll";
import { useIncidentStatus } from "../lib/hooks/useIncidentStatus";
import { useConnection } from "../lib/hooks/useConnection";
import { useAudioNotifications } from "../lib/hooks/useAudioNotifications";
import { usePhaseTransitions } from "../lib/hooks/usePhaseTransitions";
import { useAgentCompletions } from "../lib/hooks/useAgentCompletions";
import { useFallback } from "../lib/hooks/useFallback";
import { useStateSync } from "../lib/hooks/useStateSync";
import { ErrorBoundary, useErrorHandler } from "../lib/error-boundary";
import { useFallbackManager } from "../lib/fallback-handlers";

interface Incident {
  id: string;
  title: string;
  description: string;
  severity: "low" | "medium" | "high" | "critical";
  status: "active" | "resolving" | "resolved";
  created_at: string;
  affected_services: string[];
  metrics: Record<string, any>;
  estimated_cost: number;
  resolution_time?: number;
}

interface AgentAction {
  id: string;
  agent_type:
    | "detection"
    | "diagnosis"
    | "prediction"
    | "resolution"
    | "communication";
  title: string;
  description: string;
  timestamp: string;
  confidence?: number;
  status: "pending" | "in_progress" | "completed" | "failed";
  details?: Record<string, any>;
  duration?: number;
  impact?: string;
}

interface DashboardState {
  currentIncident: Incident | null;
  agentActions: AgentAction[];
  metrics: typeof incidentCommanderMetrics;
  systemStatus: "autonomous" | "monitoring" | "incident" | "maintenance";
  isConnected: boolean;
}

const scenarioConfigs = {
  database: {
    icon: Database,
    title: "Database Cascade",
    description: "Connection pool exhaustion scenario",
    color: "from-red-500 to-red-600",
    bgColor: "from-red-500/10 to-red-600/10",
    borderColor: "border-red-500/20",
  },
  ddos: {
    icon: Shield,
    title: "DDoS Attack",
    description: "Traffic spike mitigation test",
    color: "from-orange-500 to-orange-600",
    bgColor: "from-orange-500/10 to-orange-600/10",
    borderColor: "border-orange-500/20",
  },
  memory: {
    icon: MemoryStick,
    title: "Memory Leak",
    description: "OOM error recovery simulation",
    color: "from-purple-500 to-purple-600",
    bgColor: "from-purple-500/10 to-purple-600/10",
    borderColor: "border-purple-500/20",
  },
  api: {
    icon: Plug,
    title: "API Overload",
    description: "Rate limit activation scenario",
    color: "from-blue-500 to-blue-600",
    bgColor: "from-blue-500/10 to-blue-600/10",
    borderColor: "border-blue-500/20",
  },
  storage: {
    icon: HardDrive,
    title: "Storage Failure",
    description: "Failover and replication test",
    color: "from-green-500 to-green-600",
    bgColor: "from-green-500/10 to-green-600/10",
    borderColor: "border-green-500/20",
  },
};

function ScenarioButton({
  scenario,
  config,
  onTrigger,
  disabled,
}: {
  scenario: string;
  config: typeof scenarioConfigs.database;
  onTrigger: (scenario: string) => void;
  disabled: boolean;
}) {
  const Icon = config.icon;

  return (
    <motion.div
      whileHover={{ scale: disabled ? 1 : 1.02 }}
      whileTap={{ scale: disabled ? 1 : 0.98 }}
    >
      <Button
        variant="outline"
        className={`w-full h-auto p-4 justify-start gap-3 bg-gradient-to-br ${config.bgColor} border ${config.borderColor} hover:bg-gradient-to-br hover:${config.bgColor} disabled:opacity-50`}
        onClick={() => onTrigger(scenario)}
        disabled={disabled}
      >
        <div
          className={`p-2 rounded-lg bg-gradient-to-br ${config.color} text-white`}
        >
          <Icon className="w-4 h-4" />
        </div>
        <div className="text-left">
          <div className="font-semibold text-sm">{config.title}</div>
          <div className="text-xs text-muted-foreground">
            {config.description}
          </div>
        </div>
      </Button>
    </motion.div>
  );
}

function EnhancedIncidentPanel({
  incident,
  trackedIncident,
  progress,
  currentPhase,
}: {
  incident: Incident | null;
  trackedIncident: any;
  progress: number;
  currentPhase: string | null;
}) {
  // Show tracked incident if available, otherwise fall back to local incident
  const displayIncident = trackedIncident || incident;

  if (!displayIncident) return null;

  // Convert incident data to match IncidentStatusPanel props
  const affectedServices = (incident?.affected_services || []).map(
    (service) => ({
      name: service,
      status: "degraded" as const,
      impact: "Service disruption",
    })
  );

  return (
    <div className="col-span-full">
      <IncidentStatusPanel
        incidentId={displayIncident.id}
        title={displayIncident.title}
        severity={
          displayIncident.severity as "critical" | "high" | "medium" | "low"
        }
        startTime={
          trackedIncident
            ? trackedIncident.startTime
            : new Date(incident?.created_at || Date.now())
        }
        affectedServices={affectedServices}
        description={displayIncident.description}
        progress={progress}
        currentPhase={currentPhase}
        isResolved={
          trackedIncident?.isComplete || incident?.status === "resolved"
        }
        resolutionTime={
          trackedIncident?.resolutionTime || incident?.resolution_time
        }
      />
    </div>
  );
}

export default function RefinedDashboard() {
  const [dashboardState, setDashboardState] = React.useState<DashboardState>({
    currentIncident: null,
    agentActions: [
      {
        id: "init",
        agent_type: "detection",
        title: "System Initialized",
        description:
          "Multi-agent system ready for autonomous incident response",
        timestamp: new Date().toISOString(),
        confidence: 1.0,
        status: "completed",
        duration: 1200,
        impact: "System Ready",
      },
    ],
    metrics: incidentCommanderMetrics,
    systemStatus: "autonomous",
    isConnected: true,
  });

  const [scenarioInProgress, setScenarioInProgress] = React.useState(false);

  // Initialize new hooks for enhanced UX
  const {
    scrollRef,
    scrollToBottom,
    shouldShowScrollToBottom,
    isAutoScrollEnabled,
    isPaused,
    handleNewMessage,
  } = useAutoScroll({
    dependencies: [dashboardState.agentActions],
    threshold: 100,
    resumeDelay: 1500,
    smoothScroll: true,
  });

  const {
    currentIncident,
    isActive: isIncidentActive,
    isResolved,
    progress: incidentProgress,
    currentPhase,
    startIncident,
    updateStatus,
    markResolved,
    onResolution,
    onPhaseTransition,
  } = useIncidentStatus({
    autoUpdate: true,
    updateInterval: 1000,
  });

  const {
    connectionState,
    isConnected,
    connect,
    disconnect,
    sendMessage,
    queueMessage,
  } = useConnection({
    config: {
      wsUrl: typeof window !== "undefined" 
        ? `${window.location.protocol === "https:" ? "wss:" : "ws:"}//localhost:8000/ws`
        : process.env.NEXT_PUBLIC_WS_URL || "",
      reconnectInterval: 1000,
      maxReconnectAttempts: 10,
      heartbeatInterval: 30000,
    },
    autoConnect: true,
    onMessage: handleWebSocketMessage,
    onError: (error) => console.error("WebSocket error:", error),
  });

  const { playNotification, isEnabled: audioEnabled } = useAudioNotifications({
    enabled: true,
  });

  const { lastTransition } = usePhaseTransitions();

  const { completions, addCompletion } = useAgentCompletions();

  const { fallbackState, triggerFallback } = useFallback();

  const { syncState, broadcastState } = useStateSync({
    key: "dashboard-state",
    initialState: dashboardState,
  });

  // Error handling and fallback mechanisms
  const { handleError } = useErrorHandler();

  const {
    state: managerFallbackState,
    handleAutoScrollFallback,
    handleConnectionFallback,
    handleIncidentTrackingFallback,
    handlePerformanceFallback,
    handleDataFallback,
    retryOperation,
  } = useFallbackManager({
    enableAutoScroll: true,
    enableConnectionFallback: true,
    enableIncidentTracking: true,
    enablePerformanceOptimization: true,
    enableDataFallback: true,
    maxRetries: 3,
    retryDelay: 1000,
  });

  // Get performance optimizations
  const performanceFallback = handlePerformanceFallback();
  const dataFallback = handleDataFallback();
  const incidentFallback = handleIncidentTrackingFallback();

  // WebSocket message handler with error handling
  function handleWebSocketMessage(data: any) {
    try {
      console.log("ðŸ“¡ Received WebSocket message:", data);

      // Handle different message types
      switch (data.type) {
        case "incident_started":
          if (data.data?.incident) {
            const incident = data.data.incident;

            // Update local state
            setDashboardState((prev) => ({
              ...prev,
              currentIncident: incident,
              systemStatus: "incident",
            }));

            // Start incident tracking
            startIncident({
              id: incident.id,
              title: incident.title,
              description: incident.description,
              severity: incident.severity,
              phase: "detection",
              startTime: new Date(incident.created_at),
            });

            // Play notification
            playNotification("incident_started");

            // Broadcast state change
            broadcastState({ type: "incident_started", incident });
          }
          break;

        case "agent_action":
          if (data.data?.action) {
            const action = data.data.action;

            setDashboardState((prev) => ({
              ...prev,
              agentActions: [action, ...prev.agentActions.slice(0, 14)],
            }));

            // Handle new message for auto-scroll
            handleNewMessage();

            // Track agent completion
            if (action.status === "completed") {
              addCompletion({
                agentType: action.agent_type,
                actionId: action.id,
                timestamp: new Date(action.timestamp),
                duration: action.duration || 0,
              });

              // Play completion notification
              playNotification("agent_completed");
            }

            // Update incident phase if needed
            if (
              currentIncident &&
              action.agent_type !== currentIncident.phase
            ) {
              updateStatus({ phase: action.agent_type });
            }
          }
          break;

        case "incident_resolved":
          setDashboardState((prev) => ({
            ...prev,
            currentIncident: null,
            systemStatus: "autonomous",
          }));

          // Mark incident as resolved
          if (data.data?.resolutionTime) {
            markResolved(data.data.resolutionTime);
          } else {
            markResolved();
          }

          // Play resolution notification
          playNotification("incident_resolved");
          break;

        case "phase_transition":
          if (data.data?.phase && currentIncident) {
            updateStatus({ phase: data.data.phase });
            playNotification("phase_transition");
          }
          break;

        default:
          console.log("Unknown message type:", data.type);
      }
    } catch (error) {
      console.error("Error handling WebSocket message:", error);
      handleError(error as Error);

      // Activate data fallback if message handling fails repeatedly
      if (!fallbackState.dataFallbackActive) {
        console.warn("Activating data fallback due to message handling errors");
      }
    }
  }

  // Update connection state in dashboard state
  React.useEffect(() => {
    setDashboardState((prev) => ({
      ...prev,
      isConnected,
    }));
  }, [isConnected]);

  // Handle connection failures with fallback
  React.useEffect(() => {
    if (!isConnected && connectionState.status === "error") {
      console.warn("WebSocket connection failed, attempting fallback");

      // Try connection fallback (polling mode)
      retryOperation("websocket-connection", async () => {
        await handleConnectionFallback("/api/dashboard/status", (data) => {
          // Handle polling data
          if (data.incident) {
            handleWebSocketMessage({ type: "incident_started", data });
          }
          if (data.actions) {
            data.actions.forEach((action: any) => {
              handleWebSocketMessage({
                type: "agent_action",
                data: { action },
              });
            });
          }
        });
      });
    }
  }, [
    isConnected,
    connectionState.status,
    handleConnectionFallback,
    retryOperation,
  ]);

  // Handle auto-scroll failures
  React.useEffect(() => {
    if (fallbackState.autoScrollFailed && scrollRef.current) {
      console.warn("Auto-scroll failed, using fallback");
      handleAutoScrollFallback(scrollRef.current);
    }
  }, [fallbackState.autoScrollFailed, handleAutoScrollFallback]);

  // Handle incident tracking failures
  React.useEffect(() => {
    if (fallbackState.incidentTrackingFailed) {
      console.warn("Incident tracking failed, using local fallback");
      // The fallback is already set up in incidentFallback
    }
  }, [fallbackState.incidentTrackingFailed]);

  // Set up incident resolution handler
  React.useEffect(() => {
    const unsubscribe = onResolution((resolution) => {
      console.log("ðŸŽ‰ Incident resolved:", resolution);

      // Show celebration notification
      if (resolution.showCelebration) {
        playNotification("celebration");
      }

      // Update dashboard state after delay
      setTimeout(() => {
        setDashboardState((prev) => ({
          ...prev,
          currentIncident: null,
          systemStatus: "autonomous",
        }));
      }, resolution.fadeOutDelay);
    });

    return unsubscribe;
  }, [onResolution, playNotification]);

  // Set up phase transition handler
  React.useEffect(() => {
    const unsubscribe = onPhaseTransition((transition) => {
      console.log("ðŸ”„ Phase transition:", transition);
      playNotification("phase_transition");
    });

    return unsubscribe;
  }, [onPhaseTransition, playNotification]);

  // Simulate periodic metric updates
  React.useEffect(() => {
    const metricsInterval = setInterval(() => {
      setDashboardState((prev) => ({
        ...prev,
        metrics: prev.metrics.map((metric) => {
          if (Math.random() < 0.1 && typeof metric.value === "number") {
            const variation = Math.random() * 0.05 - 0.025; // Â±2.5% variation
            const newValue = Math.max(
              0,
              Math.round(metric.value * (1 + variation))
            );
            return {
              ...metric,
              previousValue: metric.value,
              value: newValue,
            };
          }
          return metric;
        }),
      }));
    }, 5000);

    return () => clearInterval(metricsInterval);
  }, []);

  const triggerScenario = async (scenarioType: string) => {
    if (scenarioInProgress) return;

    setScenarioInProgress(true);

    try {
      // Use fallback incident tracking if main tracker fails
      const incidentTracker = fallbackState.incidentTrackingFailed
        ? incidentFallback
        : { startIncident, updateStatus, markResolved };
      // Create mock incident
      const incident: Incident = {
        id: Date.now().toString(),
        title: `${
          scenarioConfigs[scenarioType as keyof typeof scenarioConfigs].title
        } Detected`,
        description: `Autonomous system detected ${scenarioType} incident and initiating response`,
        severity: "high",
        status: "active",
        created_at: new Date().toISOString(),
        affected_services: ["web-api", "database", "cache"],
        metrics: {
          cpu_usage: "85%",
          memory_usage: "92%",
          error_rate: "12%",
          response_time: "2.3s",
        },
        estimated_cost: 15000,
      };

      // Update system status
      setDashboardState((prev) => ({
        ...prev,
        currentIncident: incident,
        systemStatus: "incident",
      }));

      // Start incident tracking with error handling
      try {
        incidentTracker.startIncident({
          id: incident.id,
          title: incident.title,
          description: incident.description,
          severity: incident.severity as "critical" | "high" | "medium" | "low",
          phase: "detection",
          startTime: new Date(incident.created_at),
        });
      } catch (error) {
        console.error("Failed to start incident tracking:", error);
        // Use fallback tracking
        incidentFallback.startIncident({
          id: incident.id,
          title: incident.title,
          description: incident.description,
          severity: incident.severity,
        });
      }

      // Add detection action
      const detectionAction: AgentAction = {
        id: `detection-${Date.now()}`,
        agent_type: "detection",
        title: "Incident Detected",
        description: `Critical ${scenarioType} incident detected through anomaly analysis`,
        timestamp: new Date().toISOString(),
        confidence: 0.95,
        status: "completed",
        duration: 850,
        details: {
          severity: incident.severity,
          affected_services: incident.affected_services.length,
          detection_method: "ML Anomaly Detection",
        },
      };

      setDashboardState((prev) => ({
        ...prev,
        agentActions: [detectionAction, ...prev.agentActions],
      }));

      // Handle new message for auto-scroll
      handleNewMessage();

      // Add agent completion
      addCompletion({
        agentType: "detection",
        actionId: detectionAction.id,
        timestamp: new Date(),
        duration: 850,
      });

      // Simulate agent workflow
      const agentSequence = [
        {
          type: "diagnosis",
          title: "Root Cause Analysis",
          description: "Analyzing logs and traces to identify root cause",
          delay: 2000,
          duration: 1200,
        },
        {
          type: "prediction",
          title: "Impact Prediction",
          description: "Forecasting incident escalation and business impact",
          delay: 1000,
          duration: 800,
        },
        {
          type: "resolution",
          title: "Automated Resolution",
          description: "Executing automated remediation actions",
          delay: 1500,
          duration: 2000,
        },
        {
          type: "communication",
          title: "Stakeholder Notification",
          description: "Notifying relevant teams and updating status",
          delay: 500,
          duration: 300,
        },
      ];

      let totalDelay = 1000;

      for (const step of agentSequence) {
        setTimeout(() => {
          const action: AgentAction = {
            id: `${step.type}-${Date.now()}`,
            agent_type: step.type as any,
            title: step.title,
            description: step.description,
            timestamp: new Date().toISOString(),
            confidence: 0.85 + Math.random() * 0.1,
            status: "in_progress",
            duration: step.duration,
          };

          setDashboardState((prev) => ({
            ...prev,
            agentActions: [action, ...prev.agentActions],
          }));

          // Handle new message for auto-scroll with fallback
          try {
            handleNewMessage();
          } catch (error) {
            console.error("Auto-scroll failed:", error);
            if (scrollRef.current) {
              handleAutoScrollFallback(scrollRef.current);
            }
          }

          // Update incident phase with error handling
          try {
            if (incidentTracker.updateStatus) {
              incidentTracker.updateStatus({ phase: step.type as any });
            } else if (incidentTracker.updateIncident) {
              incidentTracker.updateIncident({ phase: step.type });
            } else {
              incidentFallback.updateIncident({ phase: step.type });
            }
          } catch (error) {
            console.error("Failed to update incident phase:", error);
            incidentFallback.updateIncident({ phase: step.type });
          }

          // Complete the action after duration
          setTimeout(() => {
            setDashboardState((prev) => ({
              ...prev,
              agentActions: prev.agentActions.map((a) =>
                a.id === action.id ? { ...a, status: "completed" as const } : a
              ),
            }));

            // Add agent completion
            addCompletion({
              agentType: step.type as any,
              actionId: action.id,
              timestamp: new Date(),
              duration: step.duration,
            });

            // Handle new message for auto-scroll
            handleNewMessage();
          }, step.duration);
        }, totalDelay);

        totalDelay += step.delay + step.duration;
      }

      // Resolve incident
      setTimeout(() => {
        const resolutionTime = totalDelay / 1000;

        setDashboardState((prev) => ({
          ...prev,
          currentIncident: prev.currentIncident
            ? {
                ...prev.currentIncident,
                status: "resolved",
                resolution_time: resolutionTime,
              }
            : null,
          systemStatus: "autonomous",
        }));

        // Mark incident as resolved in tracker with error handling
        try {
          if (incidentTracker.markResolved) {
            incidentTracker.markResolved(resolutionTime);
          } else if (incidentTracker.resolveIncident) {
            incidentTracker.resolveIncident();
          } else {
            incidentFallback.resolveIncident();
          }
        } catch (error) {
          console.error("Failed to mark incident resolved:", error);
          incidentFallback.resolveIncident();
        }

        // Hide incident after celebration (handled by resolution callback)
        setTimeout(() => {
          setScenarioInProgress(false);
        }, 3000);
      }, totalDelay + 1000);
    } catch (error) {
      console.error("Error triggering scenario:", error);
      handleError(error as Error);

      // Use fallback data if scenario fails
      if (fallbackState.dataFallbackActive) {
        const mockIncident = dataFallback.getMockIncident();
        setDashboardState((prev) => ({
          ...prev,
          currentIncident: mockIncident,
          systemStatus: "incident",
          agentActions: [
            ...dataFallback.getMockAgentActions(),
            ...prev.agentActions,
          ],
        }));
      }

      setScenarioInProgress(false);
    }
  };

  return (
    <ErrorBoundary
      onError={(error, errorInfo) => {
        console.error("Dashboard error:", error, errorInfo);
        // Activate all fallback mechanisms
        if (!fallbackState.dataFallbackActive) {
          console.warn("Activating all fallback mechanisms due to dashboard error");
        }
      }}
    >
      <div className="min-h-screen bg-background">
        <ErrorBoundary fallback={
          <div className="p-4 bg-red-50 border border-red-200 rounded-md">
            <p className="text-red-800">Header failed to load. Using fallback mode.</p>
          </div>
        }>
          <div className="relative">
            <IncidentCommanderHeader
              systemStatus={dashboardState.systemStatus}
              stats={{
                activeIncidents: dashboardState.currentIncident ? 1 : 0,
                resolvedToday: 12,
                mttrReduction: 95,
                agentsActive: 5,
              }}
              onTriggerScenario={triggerScenario}
            />

            {/* Connection Status Indicator */}
            <div className="absolute top-4 right-4">
              <ErrorBoundary fallback={
                <Badge variant="outline" className="bg-red-50 text-red-700">
                  Connection Status Unavailable
                </Badge>
              }>
                <ConnectionStatusIndicator
                  isConnected={isConnected}
                  connectionState={connectionState}
                  onReconnect={() => connect()}
                  onDisconnect={() => disconnect()}
                />
              </ErrorBoundary>
            </div>

            {/* Fallback Status Indicators */}
            {(fallbackState.autoScrollFailed || 
              fallbackState.connectionFailed || 
              fallbackState.incidentTrackingFailed || 
              fallbackState.performanceIssues || 
              fallbackState.dataFallbackActive) && (
              <div className="absolute top-16 right-4 space-y-2">
                {fallbackState.dataFallbackActive && (
                  <Badge variant="outline" className="bg-yellow-50 text-yellow-700">
                    Fallback Mode Active
                  </Badge>
                )}
                {fallbackState.performanceIssues && (
                  <Badge variant="outline" className="bg-orange-50 text-orange-700">
                    Performance Mode
                  </Badge>
                )}
              </div>
            )}
          </div>
        </ErrorBoundary>

      <div className="p-6">
        <div className="max-w-7xl mx-auto">
          <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
            {/* Activity Feed - Takes up 2 columns */}
            <div className="lg:col-span-2 relative">
              <ErrorBoundary fallback={
                <div className="p-4 bg-red-50 border border-red-200 rounded-md">
                  <p className="text-red-800">Activity feed failed to load.</p>
                  <Button 
                    onClick={() => window.location.reload()} 
                    className="mt-2"
                    size="sm"
                  >
                    Reload
                  </Button>
                </div>
              }>
                <div ref={scrollRef} className="h-full">
                  <ActivityFeed
                    actions={fallbackState.dataFallbackActive 
                      ? [...dataFallback.getMockAgentActions(), ...dashboardState.agentActions]
                      : dashboardState.agentActions
                    }
                    maxItems={15}
                  />
                </div>
              </ErrorBoundary>

              {/* Scroll to bottom button */}
              <AnimatePresence>
                {shouldShowScrollToBottom && (
                  <motion.div
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 20 }}
                    className="absolute bottom-4 right-4"
                  >
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => scrollToBottom(true)}
                      className="bg-background/80 backdrop-blur-sm border-primary/20 hover:bg-primary/10"
                    >
                      <ArrowDown className="w-4 h-4 mr-1" />
                      New Messages
                    </Button>
                  </motion.div>
                )}
              </AnimatePresence>

              {/* Auto-scroll status indicator */}
              {isPaused && (
                <div className="absolute top-4 right-4">
                  <Badge
                    variant="outline"
                    className="bg-background/80 backdrop-blur-sm"
                  >
                    <Pause className="w-3 h-3 mr-1" />
                    Auto-scroll paused
                  </Badge>
                </div>
              )}
            </div>

            {/* Right Sidebar */}
            <div className="lg:col-span-2 space-y-6">
              {/* Scenario Controls */}
              <ErrorBoundary fallback={
                <Card>
                  <CardContent className="p-4">
                    <p className="text-red-800">Scenario controls failed to load.</p>
                  </CardContent>
                </Card>
              }>
                <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-500/10 to-purple-600/10 border border-purple-500/20 flex items-center justify-center">
                      <Play className="w-4 h-4 text-purple-500" />
                    </div>
                    Demo Scenarios
                    {scenarioInProgress && (
                      <Badge variant="outline" className="ml-auto">
                        <Pause className="w-3 h-3 mr-1" />
                        Running
                      </Badge>
                    )}
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  {Object.entries(scenarioConfigs).map(([scenario, config]) => (
                    <ScenarioButton
                      key={scenario}
                      scenario={scenario}
                      config={config}
                      onTrigger={triggerScenario}
                      disabled={scenarioInProgress}
                    />
                  ))}
                </CardContent>
                </Card>
              </ErrorBoundary>

              {/* Metrics Panel */}
              <ErrorBoundary fallback={
                <Card>
                  <CardContent className="p-4">
                    <p className="text-red-800">Metrics panel failed to load.</p>
                  </CardContent>
                </Card>
              }>
                <MetricsPanel
                  metrics={fallbackState.dataFallbackActive 
                    ? [...dataFallback.getMockMetrics(), ...dashboardState.metrics]
                    : dashboardState.metrics
                  }
                  title="Live System Metrics"
                  animated={!performanceFallback.shouldDisableAnimations}
                />
              </ErrorBoundary>
            </div>

            {/* Incident Panel - Full width when active */}
            <AnimatePresence>
              {(dashboardState.currentIncident || currentIncident) && (
                <ErrorBoundary fallback={
                  <div className="col-span-full">
                    <Card>
                      <CardContent className="p-4">
                        <p className="text-red-800">Incident panel failed to load.</p>
                      </CardContent>
                    </Card>
                  </div>
                }>
                  <EnhancedIncidentPanel
                    incident={dashboardState.currentIncident}
                    trackedIncident={currentIncident}
                    progress={incidentProgress}
                    currentPhase={currentPhase}
                  />
                </ErrorBoundary>
              )}
            </AnimatePresence>
          </div>
        </div>
      </div>
    </ErrorBoundary>
  );
}
