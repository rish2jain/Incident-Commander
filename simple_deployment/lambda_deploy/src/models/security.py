"""
Security-related data models for the Autonomous Incident Commander.

This module defines Pydantic models for security events, audit logs,
agent authentication, and compliance reporting.
"""

from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field, field_validator
import hashlib
import json


class SecurityEventType(str, Enum):
    """Types of security events that can be logged."""
    AGENT_AUTHENTICATION = "agent_authentication"
    AGENT_AUTHORIZATION = "agent_authorization"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_ACCESS = "data_access"
    CONFIGURATION_CHANGE = "configuration_change"
    SECURITY_VIOLATION = "security_violation"
    SUSPICIOUS_BEHAVIOR = "suspicious_behavior"
    AGENT_COMPROMISE = "agent_compromise"
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    CRYPTOGRAPHIC_FAILURE = "cryptographic_failure"


class SecuritySeverity(str, Enum):
    """Security event severity levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AuditEvent(BaseModel):
    """
    Tamper-proof audit event with cryptographic integrity verification.
    
    All security-relevant events are logged as AuditEvents with
    cryptographic hashing to prevent tampering.
    """
    event_id: str = Field(..., description="Unique event identifier")
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    event_type: SecurityEventType
    severity: SecuritySeverity
    agent_id: Optional[str] = Field(None, description="Agent that triggered the event")
    user_id: Optional[str] = Field(None, description="User associated with the event")
    source_ip: Optional[str] = Field(None, description="Source IP address")
    resource: Optional[str] = Field(None, description="Resource being accessed")
    action: str = Field(..., description="Action being performed")
    outcome: str = Field(..., description="Success, failure, or blocked")
    details: Dict[str, Any] = Field(default_factory=dict)
    integrity_hash: Optional[str] = Field(None, description="Cryptographic integrity hash")
    
    def calculate_integrity_hash(self) -> str:
        """Calculate cryptographic hash for tamper detection."""
        # Create a deterministic representation excluding the hash itself
        data = {
            "event_id": self.event_id,
            "timestamp": self.timestamp.isoformat(),
            "event_type": self.event_type,
            "severity": self.severity,
            "agent_id": self.agent_id,
            "user_id": self.user_id,
            "source_ip": self.source_ip,
            "resource": self.resource,
            "action": self.action,
            "outcome": self.outcome,
            "details": self.details
        }
        
        # Sort keys for deterministic hashing
        json_str = json.dumps(data, sort_keys=True, default=str)
        return hashlib.sha256(json_str.encode()).hexdigest()
    
    def verify_integrity(self) -> bool:
        """Verify the integrity hash matches the event data."""
        if not self.integrity_hash:
            return False
        return self.integrity_hash == self.calculate_integrity_hash()
    
    def __init__(self, **data):
        """Initialize AuditEvent with automatic integrity hash calculation."""
        if 'integrity_hash' not in data or data['integrity_hash'] is None:
            # Calculate hash after setting other fields
            super().__init__(**data, integrity_hash="")
            self.integrity_hash = self.calculate_integrity_hash()
        else:
            super().__init__(**data)


class SecurityAlert(BaseModel):
    """Security alert generated by behavioral analysis or threat detection."""
    alert_id: str = Field(..., description="Unique alert identifier")
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    alert_type: str = Field(..., description="Type of security alert")
    severity: SecuritySeverity
    agent_id: Optional[str] = Field(None, description="Agent involved in the alert")
    description: str = Field(..., description="Human-readable alert description")
    indicators: List[str] = Field(default_factory=list, description="Security indicators")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="Alert confidence")
    mitigation_actions: List[str] = Field(default_factory=list)
    status: str = Field(default="open", description="Alert status")
    resolved_at: Optional[datetime] = None
    resolution_notes: Optional[str] = None


class AgentCertificate(BaseModel):
    """Agent cryptographic certificate for identity verification."""
    agent_id: str = Field(..., description="Unique agent identifier")
    certificate_id: str = Field(..., description="Certificate identifier")
    public_key: str = Field(..., description="Agent's public key (PEM format)")
    issued_at: datetime = Field(default_factory=datetime.utcnow)
    expires_at: datetime = Field(..., description="Certificate expiration time")
    issuer: str = Field(default="incident-commander-ca", description="Certificate issuer")
    status: str = Field(default="active", description="Certificate status")
    revoked_at: Optional[datetime] = None
    revocation_reason: Optional[str] = None
    
    @field_validator('expires_at')
    @classmethod
    def validate_expiration(cls, v, info):
        """Ensure certificate has reasonable expiration time."""
        if info.data and 'issued_at' in info.data:
            issued_at = info.data['issued_at']
            if v <= issued_at:
                raise ValueError("Certificate expiration must be after issuance")
            
            # Maximum certificate lifetime is 1 year
            max_lifetime = issued_at + timedelta(days=365)
            if v > max_lifetime:
                raise ValueError("Certificate lifetime cannot exceed 1 year")
        
        return v
    
    def is_valid(self) -> bool:
        """Check if certificate is currently valid."""
        now = datetime.utcnow()
        return (
            self.status == "active" and
            self.issued_at <= now <= self.expires_at and
            self.revoked_at is None
        )
    
    def is_expired(self) -> bool:
        """Check if certificate is expired."""
        return datetime.utcnow() > self.expires_at
    
    def days_until_expiry(self) -> int:
        """Get number of days until certificate expires."""
        delta = self.expires_at - datetime.utcnow()
        return max(0, delta.days)


class ComplianceReport(BaseModel):
    """Compliance report for regulatory requirements."""
    report_id: str = Field(..., description="Unique report identifier")
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    report_type: str = Field(..., description="Type of compliance report")
    period_start: datetime = Field(..., description="Report period start")
    period_end: datetime = Field(..., description="Report period end")
    compliance_framework: str = Field(..., description="Compliance framework (SOC2, GDPR, etc.)")
    
    # Compliance metrics
    total_audit_events: int = Field(default=0)
    security_violations: int = Field(default=0)
    data_retention_compliance: bool = Field(default=True)
    encryption_compliance: bool = Field(default=True)
    access_control_compliance: bool = Field(default=True)
    
    # Detailed findings
    findings: List[Dict[str, Any]] = Field(default_factory=list)
    recommendations: List[str] = Field(default_factory=list)
    
    # Report metadata
    generated_by: str = Field(default="system", description="Report generator")
    reviewed_by: Optional[str] = None
    approved_by: Optional[str] = None
    status: str = Field(default="draft", description="Report status")


class PIIRedactionResult(BaseModel):
    """Result of PII redaction scanning."""
    original_text: str = Field(..., description="Original text before redaction")
    redacted_text: str = Field(..., description="Text after PII redaction")
    redacted_items: List[Dict[str, str]] = Field(default_factory=list)
    confidence_score: float = Field(..., ge=0.0, le=1.0)
    
    @field_validator('redacted_items')
    @classmethod
    def validate_redacted_items(cls, v):
        """Validate redacted items structure."""
        for item in v:
            if 'type' not in item or 'pattern' not in item:
                raise ValueError("Each redacted item must have 'type' and 'pattern' fields")
        return v


class SecurityMetrics(BaseModel):
    """Security metrics for monitoring and dashboards."""
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    
    # Authentication metrics
    successful_authentications: int = Field(default=0)
    failed_authentications: int = Field(default=0)
    authentication_rate: float = Field(default=0.0)
    
    # Security event metrics
    security_events_total: int = Field(default=0)
    security_events_by_severity: Dict[str, int] = Field(default_factory=dict)
    security_alerts_open: int = Field(default=0)
    security_alerts_resolved: int = Field(default=0)
    
    # Agent security metrics
    active_agent_certificates: int = Field(default=0)
    expired_certificates: int = Field(default=0)
    revoked_certificates: int = Field(default=0)
    
    # Compliance metrics
    audit_events_last_24h: int = Field(default=0)
    pii_redaction_rate: float = Field(default=0.0)
    data_retention_compliance_rate: float = Field(default=1.0)
    
    # Threat detection metrics
    suspicious_behaviors_detected: int = Field(default=0)
    potential_compromises_detected: int = Field(default=0)
    automated_responses_triggered: int = Field(default=0)


class ThreatIntelligence(BaseModel):
    """Threat intelligence data for security monitoring."""
    indicator_id: str = Field(..., description="Unique indicator identifier")
    indicator_type: str = Field(..., description="Type of indicator (IP, domain, hash, etc.)")
    indicator_value: str = Field(..., description="The actual indicator value")
    threat_type: str = Field(..., description="Type of threat")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence in the indicator")
    source: str = Field(..., description="Source of the threat intelligence")
    first_seen: datetime = Field(default_factory=datetime.utcnow)
    last_seen: datetime = Field(default_factory=datetime.utcnow)
    tags: List[str] = Field(default_factory=list)
    description: Optional[str] = None
    
    def is_stale(self, max_age_days: int = 30) -> bool:
        """Check if threat intelligence is stale."""
        age = datetime.utcnow() - self.last_seen
        return age.days > max_age_days